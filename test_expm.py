
# Generated by CodiumAI
from utils.Switched_Linear import SwiLin
import numpy as np
from scipy.linalg import expm
from scipy.integrate import quad_vec
import casadi as ca

import pytest

class Tests:

    # Computes the matrix exponential of a given system matrix A[index] and time interval delta_i using CasADi.
    def test_computes_matrix_exponential(self):
        # Initialize the class object
        opt_points = 10
        nx = 2
        nu = 1
        swi_lin = SwiLin(opt_points, nx, nu)

        # Load the model
        model = {
            'num_modes': 2,
            'A': [np.array([[1, 2], [3, 4]]), np.array([[5, 6], [7, 8]])],
            'B': [np.array([1, 2]), np.array([3, 4])]
        }
        swi_lin.load_model(model)

        # Precompute matrices
        # swi_lin.precompute_matrices()
        s = ca.SX.sym('s')

        # Compute the matrix exponential
        index = 0
        result = swi_lin.expm(model['A'][index], swi_lin.delta[index]-s)
        
        exp_function = ca.Function('exp', [swi_lin.delta[index],s], [result])
        
        print(exp_function(1, 0))
        print(expm(model['A'][index]*1))

        # Define the expected result
        # expected_result = np.array([[51.969499, 74.741204], [112.106034, 164.083946]])

        # # Check if the computed result matches the expected result
        # np.testing.assert_allclose(result, expected_result)
    
    
    # Computes the integral of a given system matrix and input matrix over a specified time interval using CasADi for symbolic operations.
    def test_compute_integral_valid_input(self):
        # Initialize the class object
        swi_lin = SwiLin(opt_points=10, nx=2, nu=2)
    
        # Load the model
        model = {
            'num_modes': 2,
            'A': [np.array([[1, 2], [3, 4]]), np.array([[5, 6], [7, 8]])],
            'B': [np.array([1, 2]), np.array([3, 4])]
        }
        swi_lin.load_model(model)
        index = 0
    
        # Define the time interval
        tmin = 0
        tmax = swi_lin.delta[index]

        print(tmax.is_symbolic())
        # Call the compute_integral method
        result = swi_lin.compute_integral(model['A'][index], model['B'][index], tmin, tmax)
        
        int = ca.Function('int', [tmax], [result])
        
        int_fun = lambda t: (expm(model['A'][index]*(1-t)) @ model['B'][index])
        num_int = quad_vec(int_fun, tmin, 1)
    
        
        print(int(1))
        print(num_int)
        # # Assert that the result is a numpy array
        # assert isinstance(result, np.ndarray)
    
        # # Assert that the shape of the result is correct
        # assert result.shape == (2, 2)
        
    def test_mat_exp_prop(self):
        # Initialize the class object
        swi_lin = SwiLin(opt_points=10, nx=2, nu=2)
    
        # Load the model
        model = {
            'num_modes': 2,
            'A': [np.array([[1, 2], [3, 4]]), np.array([[5, 6], [7, 8]])],
            'B': [np.array([1, 2]), np.array([3, 4])]
        }
        swi_lin.load_model(model)
        index = 0
        
        # Define the initial condition
        x0 = np.array([1, 1])
        
        # Define the control input
        u = ca.SX.sym('u', 1, 1)
    
        # Call the compute_integral method
        [x, E, phi_f, H] = swi_lin.mat_exp_prop(index, x0, u)
        
        print(f"x: {x.shape}")
        print(f"E: {E.shape}")
        print(f"phi_f: {phi_f.shape}")
        print(f"H: {H.shape}")
        
    def test_transition_matrix(self):
        # Initialize the class object
        swi_lin = SwiLin(opt_points=10, nx=2, nu=2)
    
        # Load the model
        model = {
            'num_modes': 2,
            'A': [np.array([[1, 2], [3, 4]]), np.array([[5, 6], [7, 8]])],
            'B': [np.array([1, 2]), np.array([3, 4])]
        }
        swi_lin.load_model(model)
        index = 0
        
        # Define the initial condition
        x0 = np.array([1, 1])
        
        # Define the control input
        u = ca.SX.sym('u', 1, 1)
    
        # Call the compute_integral method
        [x, E, phi_f, H] = swi_lin.transition_matrix(index, x0, u)
        
        print(f"x: {x.shape}")
        print(f"E: {E.shape}")
        print(f"phi_f: {phi_f.shape}")
        print(f"H: {H.shape}")
        
        
    def test_computes_D_matrix(self):
        # Initialize the SwiLin class
        swi_lin = SwiLin(opt_points=10, nx=2, nu=1)

        # Load the switched linear model
        model = {
            'num_modes': 2,
            'A': [np.array([[1, 2], [3, 4]]), np.array([[5, 6], [7, 8]])],
            'B': [np.array([[1], [2]]), np.array([[3], [4]])]
        }
        swi_lin.load_model(model)

        # Define the inputs
        index = 0
        Q = np.diag([1, 1, 0])
        ui = ca.SX.sym('ui', 1)
        tau_i = 0

        # Invoke the D_matrix method
        result = swi_lin.D_matrix(index, Q, ui, tau_i)
        
        print(result.shape)
        
    # Computes the G matrix when given a valid weight matrix R.
    def test_valid_weight_matrix(self):
        # Initialize the SwiLin class
        swi_lin = SwiLin(opt_points=5, nx=3, nu=2)

        # Define the weight matrix
        R = np.array([[1, 0], [0, 1]])

        # Invoke the G_matrix method
        G = swi_lin.G_matrix(R)
        
        print(G.shape)
        
    # The method should correctly augment the weight matrices Q and E with a zero block.
    def test_precompute_matrices(self):
        # Initialize the class object
        opt_points = 10
        nx = 2
        nu = 1
        swi_lin = SwiLin(opt_points, nx, nu)

        # Load the model
        model = {
            'num_modes': 2,
            'A': [np.array([[1, 2], [3, 4]]), np.array([[5, 6], [7, 8]])],
            'B': [np.array([1, 2]), np.array([3, 4])]
        }
        swi_lin.load_model(model)
        
        # Define the initial state
        x0 = ca.SX([0, 0])

        # Define the weight matrices
        Q = np.array([[1, 0], [0, 1]])
        R = np.array([[1]])
        E = np.array([[10, 0], [0, 10]])

        # Invoke the precompute_matrices method
        swi_lin.precompute_matrices(x0, Q, R, E)
        
        
if __name__ == "__main__":
    prova = Tests()
    prova.test_compute_integral_valid_input()

    


